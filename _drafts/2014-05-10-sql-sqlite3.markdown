---
layout: post
title: SQL SQLite3 sql sql sql sql sql sql sql sql sql sql sql sql sql sql sql sql
  sql sql sql sql sql sql sql sql sql sql sql sql sql sql sql sql sql sql sql sql
  sql sql sql sql sql sql sql sql sql sql sql sql sql sql sql sql sql sql
categories: []
tags:
- SQL
- SQLite3
status: publish
type: post
published: true
meta:
  _encloseme: '1'
author:
  login: vadimbrodsky
  email: vadim@vadimbrodsky.com
  display_name: Vadim
  first_name: Vadim
  last_name: Brodsky
---
<p>#SQL #SQLite3</p>
<p># SQLite 3</p>
<p>## Virtual table to see the databse structure.</p>
<p>```sql<br />
SELECT * FROM SQLITE_MASTER;<br />
```</p>
<p>## Creates a new table, with 3 columns.<br />
- To Create an id for each row use `id INTEGER PRIMARY KEY`.<br />
- To keep track of the highest ID for the row use `AUTOINCREMENT`.</p>
<p>```sql<br />
CREATE TABLE t (a INT, b REAL, c TEXT);<br />
CREATE TABLE t (id INTEGER PRIMARY KEY, a, b, c);<br />
CREATE TABLE t (id INTEGER PRIMARY KEY AUTOINCREMENT, a, b, c);<br />
```</p>
<p>- Creates a new table, makes sure it's not overwriting.</p>
<p>```sql<br />
CREATE TABLE IF NOT EXISTS t (a, b, c);<br />
```</p>
<p>## Data Types and Affinity<br />
- SQLite 3 uses manifest typing, the type values is determined by the value itself.<br />
- SQLite has 5 storage classes: `NULL`,`INTEGER`, `REAL`, `TEXT` and `BLOB`.<br />
- Dates and times are stored as `TEXT`, `REAL` or `INTEGER` depending on representation.<br />
- Type affinity is a recommendation for the column data: `NONE`, `TEXT`, `NUMERIC`, `REAL`.<br />
- Affinity is based upon column definition.</p>
<p>### TEXT Affinity<br />
- Stores values as `NULL`,`TEXT`, or `BLOB`.<br />
- Numerical data is converted to `TEXT`<br />
- Column type contains one of the following: `CHAR`, `CLOB`, or `TEXT`.</p>
<p>### NUMERIC Affinity<br />
- `NUMERIC` Affinity - stores values as `INTEGER` or `REAL`.<br />
- Text is converted to `INTEGER` or `REAL` if conversion may be lossless and reversible.<br />
- 15 significant digits must be preserved.<br />
- If lossless conversion is not possible, the value is stored as `TEXT`.<br />
- It is the default affinity if none of the other affinity rules are satisfied.<br />
- Booleans are stored as integer values: 0 and 1.</p>
<p>### INTEGER Affinity<br />
- `INTEGER` affinity - works like `NUMERIC` but prefers `INTEGER` storage<br />
-  The column type contains string `INT`</p>
<p>### REAL Affinity<br />
-  `REAL` affinity - works like `NUMERIC` but prefers `REAL` storage.<br />
-  The column type contains `REAL`, `FLOAT` or `DOUB`</p>
<p>### NONE Affinity<br />
-  `NONE` affinity - if the column type contains `BLOB` or no type specified.<br />
-  `BLOB` is a Binary Large Object.<br />
-  To store a Binary object create a column as `BLOB` or `NONE` and cast when inserting it.</p>
<p>```sql<br />
CREATE TABLE t (a INT, b REAL, c TEXT, d BLOB);<br />
CREATE TABLE t (a INT, b REAL, c TEXT, d BLOB);<br />
INSERT INTO t VALUES (1,2,3,4);<br />
INSERT INTO t VALUES ('one','two','three','four');<br />
INSERT INTO t VALUES ('a','b','c');<br />
INSERT INTO t VALUES ('1','2','3','4');<br />
INSERT INTO t (d) VALUES (CAST('xxx' AS BLOB));<br />
SELECT * FROM t;<br />
SELECT TYPEOF(a), TYPEOF(b), TYPEOF(c), TYPEOF(d) FROM t;<br />
```</p>
<p>## Representing Booleans in SQLite 3<br />
- Booleans are stored as integers: 1 or 0.<br />
- Any non-zero number is true, 0 is false.</p>
<p>```sql<br />
CREATE TABLE booltest (a INT, b INT);<br />
INSERT INTO booltest VALUES (0,1);<br />
SELECT * FROM booltest;<br />
SELECT<br />
  CASE WHEN a THEN 'TRUE' ELSE 'FALSE' END as boolA,<br />
  CASE WHEN B THEN 'TRUE' ELSE 'FALSE' END as boolb<br />
  FROM booltest;<br />
```</p>
<p>## IF Statement in SQLite 3<br />
- SQLite does not have an If / Else statement.<br />
- Use the `CASE` statement instead.</p>
<p>## Representing Date / Time in SQLite 3<br />
- Use the SQLite `DATETIME` function.<br />
    - Use `DATE()` for date only.<br />
    - Use `TIME()` for time only.<br />
- DATETIME('now') - uses the GMT time.<br />
- DATETIME('now', 'localtime') - tries to find out local time.<br />
- JULIANDAY() - gives the julian date at Greenwitch. Best for high resolution, precision and logs.<br />
- STRFTIME - gives the unix time, number of seconds from Jan 1 1970.</p>
<p>```sql<br />
CREATE TABLE t (d1 TEXT, d2 TEXT, d3 REAL, d4 INT);<br />
INSERT INTO t VALUES (DATETIME('now'), DATETIME('now', 'localtime'), JULIANDAY(), STRFTIME('%s', 'now'));<br />
SELECT d1, TYPEOF(d1), d2, TYPEOF(d2), d3, TYPEOF(d3), d4, TYPEOF(d4) FROM t;<br />
SELECT DATETIME(d3), DATETIME(d4, 'unixepoch') FROM t;<br />
```</p>
<p>## Type of Function to Find out the data types</p>
<p>```sql<br />
SELECT TYPEOF(a), TYPEOF(b), TYPEOF(c) FROM t;<br />
```</p>
<p>## Data Type Casting<br />
- Useful to display the data in a differnet way than the way it was stored.<br />
- Good for dollar amounts, to preserve precision.<br />
- The `AS` keyword will name the new view column as Dollars.</p>
<p>```sql<br />
SELECT CAST(b AS REAL) / 100 AS Dollars FROM i;<br />
SELECT TYPEOF(CAST (1 AS TEXT));<br />
```</p>
<p>## Add data to the database table</p>
<p>```sql<br />
CREATE TABLE a (a,b,c);<br />
CREATE TABLE b (d,e,f);</p>
<p>INSERT INTO a (a,b,c) VALUES ('A','B','C');<br />
INSERT INTO a VALUES ('a','b','c');<br />
INSERT INTO a (b,c) VALUES('B','C');</p>
<p>INSERT INTO b SELECT c, b, a FROM a;<br />
--- INSERT INTO b (f,e,d) SELECT * FROM a;<br />
```</p>
<p>## Updating the data in the database<br />
- Use the `UPDATE` command to update the value in the database.<br />
- Make sure to specify `WHERE` otherwire it will overwritte all data.</p>
<p>```sql<br />
UPDATE t SET quote = 'Updated Quote' WHERE id = 4;<br />
UPDATE t SET quote = 'New Quote', byline = 'Author' WHERE id = 4;<br />
```</p>
<p>## Delete data from the database<br />
- Can use an ID or any other identifier.<br />
- Must include the `WHERE` clause, otherwise all of the data will be deleted.</p>
<p>```sql<br />
DELETE FROM t WHERE id = 5;<br />
DELETE * FROM track WHERE title='Fake Track';</p>
<p>DELETE * FROM track; -- will delete the whole table.<br />
```</p>
<p>## View data from the database - SELECT<br />
- To view data from the database use select<br />
- Use `ROWID`, `OID`, `_ROWID_` to see the unique row id for each row.</p>
<p>```sql<br />
SELECT Name FROM Country;<br />
SELECT * FROM Country;<br />
SELECT ROWID, Name, Code FROM Country;<br />
```</p>
<p>Simple Selects:<br />
```sql<br />
SELECT * FROM SQLITE_MASTER;<br />
SELECT * FROM album;<br />
SELECT title, artist, label FROM album;<br />
SELECT 'Hello, World' AS 'Bob';<br />
SELECT id FROM album WHERE artist IN ('Jimi Hendrix', 'Johnny Winter');<br />
```</p>
<p>Sub Select:<br />
```sql<br />
-- Sub Select<br />
SELECT * FROM track WHERE album_id IN (<br />
  SELECT id FROM album WHERE artist IN ('Jimi Hendrix', 'Johnny Winter')<br />
);<br />
```</p>
<p>Pseudo Join:<br />
```sql<br />
-- Pseudo Join<br />
SELECT a.title AS album, t.title AS track, t.track_number<br />
  FROM album AS a, track As t<br />
  WHERE a.id = t.album_id<br />
  ORDER BY a.title, t.track_number;<br />
```</p>
<p>## Database Join<br />
- Access relationship between tables in a relational database.<br />
- Join uses 2 clauses - `JOIN` the table to join and `ON` the condition.<br />
- Additional arguments can br `WHERE` for greater specificity.<br />
- To order the data view in a particulat manner (alpha, numeric) use `ORDER BY`.</p>
<p>```sql<br />
SELECT c.Name, l.Language<br />
  FROM CountryLanguage AS l<br />
  JOIN Country AS c<br />
    ON l.CountryCode = c.Code<br />
  WHERE c.Name = 'United States'<br />
  ORDER BY l.Language<br />
```</p>
<p>```sql<br />
SELECT a.artist, a.title AS album, t.title AS track, t.track_number<br />
  FROM track as t<br />
  JOIN album as a<br />
    ON t.album_id = a.id<br />
  ORDER BY a.artist, album, t.track_number;<br />
```</p>
<p>## Database Count Function<br />
- Count the amount of matching results.</p>
<p>```sql<br />
SELECT COUNT(*) FROM track;<br />
```</p>
<p>## Database Index<br />
- Creates an index for faster join operations<br />
- Makes the writes slower</p>
<p>```sql<br />
CREATE INDEX IF NOT EXISTS co_code ON Country (Code);<br />
-- This statement is commented out.<br />
```</p>
<p>## Delete a Table from the Database</p>
<p>```sql<br />
DROP TABLE t;<br />
DROP TABLE IF EXISTS t;<br />
```</p>
<p>## SQLITE 3 Expressions<br />
- Anythig that will return a value in SQLite.<br />
- Expressions can be used anywhere a value can be used.<br />
- Expression use values and operators.<br />
    - Literal values can be integers, floating point numbers, strings, BLOBs, or NULLs.<br />
    - Operators: `||` for string concatenation.<br />
    - Arithmetic Operators: `* / % + -`<br />
    - Comparison Operators: `&lt;  &gt;= = == != `<br />
    - Boolean Operators: `AND OR`<br />
    - Special Operators:<br />
        - `IS` and `IS NOT` for comparisons,<br />
        - `LIKE` and `GLOB` for pattern matching,<br />
        - `BETWEEN` for comparisons: `X BETWEEN Y AND Z` is equivalent to `X &gt;= y AND X  100000000 ORDER BY Population DESC;<br />
SELECT Name, Population FROM Country WHERE Population BETWEEN 5000000 AND 10000000 ORDER BY Population DESC;<br />
SELECT Name FROM Country WHERE Name BETWEEN 'G' AND 'R' ORDER BY Name;<br />
```</p>
<p>Expressions with `LIKE` and `GLOB`:<br />
```sql<br />
SELECT * FROM City WHERE Name LIKE 'z%' ORDER BY Name; -- Case insensitive<br />
SELECT * FROM City WHERE Name LIKE '_w%' ORDER BY Name;<br />
SELECT * FROM City WHERE Name GLOB '?w*' ORDER BY Name; -- Case sensitive and proprietary to SQLite<br />
```</p>
<p>Expressions with Arithmetic:<br />
```sql<br />
SELECT Name, Population / 1000000 AS PopMM FROM Country<br />
  WHERE PopMM &gt; 100<br />
  ORDER BY PopMM DESC;<br />
```</p>
<p>Expressions with `IN`:<br />
```sql<br />
SELECT * FROM City WHERE CountryCode IN ('USA','GBR') ORDER BY Name;</p>
<p>SELECT * FROM City WHERE CountryCode IN<br />
  ( -- Using a sub-select<br />
    SELECT Code FROM Country WHERE Name IN ('United States', 'United Kingdom')<br />
  )<br />
  ORDER By Name;<br />
```</p>
<p>Expressions with `CASE`:<br />
```sql<br />
CREATE TABLE booltest (a,b);<br />
INSERT INTO booltest VALUES (0,1);<br />
SELECT<br />
  CASE WHEN a THEN 'TRUE' ELSE 'FALSE' END AS BoolA<br />
  FROM booltest;<br />
```</p>
<p>Expression with `||`<br />
```sql<br />
SELECT '$' || (CAST(1995 AS REAL) / 100);<br />
```</p>
<p>## SQLite Core Functions</p>
<p>### Length<br />
- Finding the length of the string.<br />
- Can be used anywhere an expression can be used.</p>
<p>```sql<br />
SELECT Name, Length(Name), Code FROM Country;<br />
SELECT Name, LENGTH(Name) AS Len, Code FROM Country<br />
  WHERE Len BETWEEN 10 AND 12<br />
  ORDER BY Len DESC;<br />
```</p>
<p>### Changing the Case of a String<br />
- In SQLite all uppercase appear before the lowecase letters - binary collation.<br />
- Can change the collation with `COLLATE NOCASE`.<br />
- To change case use the `UPPER` and `LOWER` functions.</p>
<p>```sql<br />
SELECT a, UPPER(a) FROM t;<br />
SELECT LOWER(b) FROM t ORDER BY UPPER(a);<br />
```</p>
<p>### Reading Parts of a String<br />
- Use the `SUBSRT(COL, Start Index, Length of Substring)` function.<br />
- The substring in SQLite is 1 based, starts with 1 and not 0.</p>
<p>```sql<br />
SELECT SUBSTR(a, 1, 2) AS State, SUBSTR(a, 3) AS STValue;<br />
```</p>
<p>### Replacing Parts of a String<br />
- String marching replacements, no pattern or regex.<br />
- Use the `REPLACE(COL, 'Thing', 'Other')` function.</p>
<p>```sql<br />
SELECT REPLACE(a, 'Thing', 'Other') FROM t;<br />
```</p>
<p>### Trimming Blank Spaces<br />
- Use the `TRIM(a)` - for trimming the blank spaces both sides of the string.<br />
- `LTRIM(a)` - trims only the left side of a string.<br />
- `RTRIM(a)` - trims only the right side of a string.</p>
<p>```sql<br />
SELECT TRIM(a) FROM t;<br />
```</p>
<p>### Absolute Values of Numbers<br />
- To get an absolute value of a number use the `ABS(a)`</p>
<p>```sql<br />
SELECT a,b FROM t ORDER BY ABS(a);<br />
```</p>
<p>### Rounding Numbers<br />
- To round numbers use the `ROUND(a)` function to 0 decimal places.<br />
- To round to 2 decimal places use the second argument - `ROUND(a,2)`</p>
<p>```sql<br />
SELECT ROUND(b, 2) FROM t;<br />
```</p>
<p>### Finding the Type Of a Value.<br />
- Beacuse of the manifest typing of SQLite it is useful to find the type of a string.<br />
- Use the `TYPEOF(a)` function.</p>
<p>```sql<br />
SELECT a, TYPEOF(a) FROM t;<br />
```</p>
<p>### Finding the Last Inserted Row ID<br />
- Use the `LAST_INSERT_ROWID()`.<br />
- Does not rely on the Primary Key, uses the SQLite internal Row ID.</p>
<p>```sql<br />
SELECT LAST_INSERT_ROWID();<br />
```</p>
<p>### Getting the Version of the SQLite Library<br />
- Use the `SQLITE_VERSION()` function.<br />
- Useful for feature detection, returns a string with the value.</p>
<p>```sql<br />
SELECT SQLITE_VERSION();<br />
```</p>
<p>### Writing User Defined Functions<br />
- Written in C or the user defined language - eg PHP.</p>
<p>## SQLite Aggregate Function<br />
- Functions that operate on multiple rows at a time.<br />
- Example the `COUNT`, `WHERE` functions.<br />
- The `GROUP BY` clause may be used with aggregates.<br />
- The `HAVING` clause is like `WHERE` for aggregates.</p>
<p>```sql<br />
SELECT CountryCode, AVG(Population) FROM City GROUP BY CountryCode;<br />
SELECT CountryCode, AVG(Population) as AvgPop FROM City GROUP BY CountryCode HAVING AvgPop &gt; 1000000;<br />
```</p>
<p>### Counting Rows<br />
- To count how many rows use the `COUNT(a)` functions.<br />
- Usually `COUNT` does not count the rows that contain NULL, use the `*` to count them too.</p>
<p>```sql<br />
SELECT COUNT(*) FROM City;<br />
SELECT District, COUNT(*) FROM City GROUP BY District;<br />
SELECT District, COUNT(*) AS Count FROM City GROUP BY District HAVING Count &gt; 10 ORDER By Count DESC;<br />
```</p>
<p>### Adding the Numeric Vlues in a Column<br />
- To add the numer value of a column use the `SUM(a)` function.<br />
- To get a floating point sum use the SQLite specific function `TOTAL(a)`.</p>
<p>```sql<br />
SELECT SUM(Population) FROM Country;<br />
SELECT TOTAL(Population) FROM Country;<br />
SELECT Continent, SUM(Population) AS Pop FROM Country GROUP BY Continent ORDER BY Pop DESC;<br />
```</p>
<p>### Finding Maximum and Minimum Values<br />
- To find the maximum use the `MAX(a)` function.<br />
- To find the minimum use the `MIN(a)` function.</p>
<p>```sql<br />
SELECT Continent, MAX(SurfaceArea) FROM Country GROUP BY Continent;</p>
<p>SELECT c.Name, csa.Continent, csa.MaxSA FROM<br />
  (SELECT Continent, MAX(SurfaceArea) AS MaxSA FROM Country GROUP By Continent) AS csa<br />
  JOIN Country AS c<br />
    ON c.SurfaceArea = csa.MaxSA<br />
  ORDER BY MaxSA DESC;<br />
```</p>
<p>### Finding Averages within AVG<br />
- Finds the average in a numeric column.</p>
<p>```sql<br />
SELECT AVG(Population) FROM City;</p>
<p>SELECT District, AVG(Population) AS AVGPop<br />
  FROM City<br />
  GROUP BY District<br />
  HAVING AVGPop &gt; 1000000<br />
  ORDER BY AVGPop DESC;<br />
```</p>
<p>### Grouping Results<br />
- Grouping the results with the `GROUP BY expression` function.<br />
- All the rows that have the same result for the expression will be grouped.<br />
- The name on the left side of the select and the group by should be the same to correspond to the results correctly.</p>
<p>```sql<br />
SELECT District, COUNT(*) FROM City GROUP BY District;<br />
```</p>
<p>### Select for Aggregation with HAVING<br />
- `HAVING` to aggregate is like `WHERE` to rows.<br />
- If `WHERE` is used, a syntax error will be thrown.</p>
<p>```sql<br />
SELECT District, AVG(Population) AS AVGPop<br />
  FROM City<br />
  GROUP BY District<br />
  HAVING AVGPop &gt; 1000000<br />
  ORDER BY AVGPop DESC;<br />
```</p>
<p>## Collation<br />
- Collation order or collation sequence is how SQLite compares or sorts data.<br />
- SQLIte supports 3 collation orders:<br />
    - BINARY - compares according to the numeric value of binary content.<br />
    - NOCASE - 26 uppercase ASCII characters are treated as equivalent to their lowercase counterparts.<br />
    - RTRIM - like BINARY, but ignores trailing spaces.<br />
- Collation may be specified in the column definition:<br />
- Collation may be specified using the `COLLATE` operator:</p>
<p>```sql<br />
CREATE TABLE t (..., column_name TYPE COLLATE BINARY, ...)<br />
SELECT * FROM t COLLATE BINARY;<br />
```</p>
<p>### Sort Data<br />
- To sort results use the `ORDER BY` function<br />
- By default sorts small to large.<br />
- Use the `DESC` to sort large to small.</p>
<p>```sql<br />
SELECT * FROM Country ORDER BY Region, Population DESC;<br />
```</p>
<p>### Removing Duplicates<br />
- To ensure that the results are unique use the `DISTINCT` function.<br />
- Operates on all of the expression in the clause, makes sure each row in the result is distinct.<br />
- Like GROUP BY but without the aggregation.</p>
<p>```sql<br />
SELECT DISTINCT Region FROM Country;<br />
```</p>
<p>### Indexes<br />
- Table is optimized for storage - many rows and columns.<br />
- Index is optimized for seaching - many rows one column.<br />
- Indexes take space and slow down INSERTs, its best to test to make sure that we get the best results possible.</p>
<p>```sql<br />
CREATE INDEX co_code ON Country(Code);<br />
CREATE INDEX ci_code ON City(CountryCode);</p>
<p>SELECT co.name, AVG(ci.Population) AS AvgPop<br />
  FROM City AS ci<br />
  JOIN Country AS co<br />
    ON co.Code = ci.CountryCode<br />
  GROUP BY ci.CountryCode<br />
  ORDER BY AvgPop DESC;<br />
```</p>
<p>### Primary Key Indexes<br />
- Used to create a unique and priary key for the index.<br />
- Only one unique primary key is allowed per table.<br />
- The primary way that other tables will find records in this table.<br />
- `NULL` values are not disallowed in priary key values - this is non standard and shoule be avoided.</p>
<p>```sql<br />
CREATE TABLE t (code PRIMARY KEY, value TEXT, ycode UNIQUE);<br />
CREATE TABLE x (code NOT NULL PRIMARY KEY, value TEXT, ycode UNIQUE);<br />
```</p>
<p>### Integer Primary Key<br />
- Each row in a table has a unique ID.<br />
- Guaranteed to be unique and most of the time sequential.<br />
- Row id can be defined explicitly by `id INTEGER PRIMARY KEY`<br />
- Does not add anything else to the table, does not take any extra space.<br />
- It's an alias to the row id that is already there.<br />
- Can use the keyword `AUTOINCREMENT` to increment the values one higher that there ever was in the table, even if rows are deleted. Creates another table in the database - sqlite_sequence.</p>
<p>```sql<br />
SELECT ROWID, a, b, c FROM t;<br />
SELECT oid, a, b, c FROM t;</p>
<p>CREATE TABLE t (id INTEGER PRIMARY KEY AUTOINCREMENT, a, b, c);<br />
SELECT _rowid_, a, b, c FROM t;<br />
```</p>
<p>## Transactions<br />
- Transaction ensure data integrity and increase the performance of databases.<br />
- SQLite is ACID-compliant - Atomicity, Consistency, Isolation, Durability.<br />
- SQLite accomplished this by using transactions.<br />
    - When there are one or more operations<br />
    - They are written to the database when it is complete<br />
    - They are rolled back if it cannot be completed<br />
    - They are locked while a transaction is in progress<br />
- Transactions may be used to improve performance - one wite is faster than 100 writes.<br />
- Transactions ensure that operations happen atomically - when multiple tables are affected if it fails, it fails on all. All done in one swoop. All or nothing.<br />
- Use the `BEGIN;`, `COMMIT;`, and `ROLLBACK;` keywords.</p>
<p>```sql<br />
BEGIN;<br />
INSERT INTO sale (item_id, quantity, price) VALUES (4, 12, 19295);<br />
UPDATE inventory SET quantity = ( SELECT quantity FROM inventory WHERE id = 4) - 12 WHERE id = 4;<br />
COMMIT;<br />
```</p>
<p>## Subselects and Views<br />
- Shows the data in a differnt way that it is organized in the database.<br />
- Subselects are nested SELECT statements, can be many levels deep.</p>
<p>```sql<br />
SELECT * FROM trck WHERE album id IN<br />
  (SELECT id FROM album WHERE artist = 'Jimi Hendrix');<br />
```</p>
<p>- Subselects may be stored as VIEWS so they can be easily reused.<br />
- A view may be used in place of subselect.<br />
- Views can be used anywhere where any other query can be used.<br />
- To view the stored viewed need to query the SQLITE_MASTER pseudo table.</p>
<p>```sql<br />
CREATE VIEW JoinedAlbum AS<br />
  SELECT a.artist AS artist, a.title AS album, t.track_number AS trackno,<br />
         t.title AS track, t.duration / 60 AS m, t.duration % 60 AS s<br />
  FROM track AS t<br />
  JOIN album a ON a.id = t.album_id;</p>
<p>SELECT artist, album, tack, trackno,<br />
  m || ':' CASE WHEN s&lt;10 THEN &#039;0&#039; || s ELSE s END AS duration<br />
  FROM JoinedAlbum;</p>
<p>  SELECT * FROM SQLITE_MASTER WHERE type=&#039;view&#039;;<br />
```</p>
<p>- The best way to work with subselect is to break the problem into 2 parts: the inner select and the outer select.</p>
<p>```sql<br />
SELECT co.Name, tt.CoValue FROM )<br />
    SELECT SUBSTR(b, 1, 2) AS Country, SUBSTR(b, 3) AS CoValue FROM t<br />
    ) as tt<br />
    JOIN Country AS co ON tt.Country = co.Code2;<br />
```</p>
